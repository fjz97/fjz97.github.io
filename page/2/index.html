<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="feng's blog"><meta name="keywords" content=""><meta name="author" content="feng"><meta name="copyright" content="feng"><title>Make noise since 1997. | 冯京哲的狗窝</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">feng</div><div class="author-info__description text-center">feng's blog</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">30</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><nav id="nav" style="background-image: url(https://sotama.cool/picture)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">冯京哲的狗窝</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">冯京哲的狗窝</div><div id="site-sub-title">Make noise since 1997.</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/04/28/java多线程下载/">java多线程下载</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/技术/">技术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><p>在上一篇文章里，我们讨论了图片缓存速度慢的原因，发现IO并不是决定因素。那么问题出在哪呢？一篇关于java多线程下载的博客引起了我的注意：我们知道迅雷、旋风等下载器都是多线程下载的，会不会是单线程效率的问题影响了图片缓存速度呢？事不宜迟，我们开始验证。</p>
<hr>
<h1 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h1><p>多线程下载的原理很简单，无非就是分段请求数据，最后再把每段数据拼凑起来，实现起来需要解决两个问题， 没错，就是怎么分段请求和怎么拼接数据。</p>
<h2 id="1-HTTP-1-1-Header-Range"><a href="#1-HTTP-1-1-Header-Range" class="headerlink" title="1.HTTP/1.1 Header Range"></a>1.HTTP/1.1 Header Range</h2><p>首先面临的问题是，怎么分段请求数据。<br>HTTP/1.1引入了一个新的header，名字叫做Range，它可以指定一个范围，然后http请求就会只请求那一段的数据，java代码可以这样写：</p>
<p><code>conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + start + &quot;-&quot; + end);</code></p>
<p>其中start就是数据的开始字节，end是数据的结束字节。</p>
<h2 id="2-RandomAccessFile"><a href="#2-RandomAccessFile" class="headerlink" title="2.RandomAccessFile"></a>2.RandomAccessFile</h2><p>第二个问题是，怎么将这些分段的数据拼接起来。<br>这里我们需要用到java随机访问文件RandomAccessFile，它指定文件并通过seek方法跳转到该文件的任意字节处进行读写操作。于是我们的java代码可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">raf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">raf.seek(start);</span><br><span class="line">byte[] bytes = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = is.read(bytes)) != -1) &#123;</span><br><span class="line">	raf.write(bytes, 0, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便测试，我写了一个java demo，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	</span><br><span class="line">	private static final String PICTURE_URL = &quot;http://d1.music.126.net/dmusic/CloudMusic_official_5.1.0.573520.apk&quot;;</span><br><span class="line">	private static final String FILE_NAME = &quot;cloudmusic.apk&quot;;</span><br><span class="line">	private static final int THREAD_NUM = 10;</span><br><span class="line">	private static long startTime;</span><br><span class="line">	private static long endTime;</span><br><span class="line">	private static double usetime;</span><br><span class="line">	private static int count = 0;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		startTime = System.currentTimeMillis();</span><br><span class="line">		try &#123;</span><br><span class="line">			File file = new File(&quot;C:/cdt/&quot;, FILE_NAME);</span><br><span class="line">			URL url = new URL(PICTURE_URL);</span><br><span class="line">			HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">			int size = conn.getContentLength();</span><br><span class="line">			int piece = size % THREAD_NUM == 0 ? size / THREAD_NUM : (size / THREAD_NUM + 1);</span><br><span class="line">			for (int j = 0; j &lt; THREAD_NUM; j++) &#123;</span><br><span class="line">				int start = j * piece;</span><br><span class="line">				int end = (j + 1) * piece - 1;</span><br><span class="line">				if (j == THREAD_NUM - 1) end = size;</span><br><span class="line">				new DownloadThread(file, url, start, end).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static class DownloadThread extends Thread &#123;</span><br><span class="line">		private File file;</span><br><span class="line">		private URL url;</span><br><span class="line">		private int start;</span><br><span class="line">		private int end;</span><br><span class="line">		</span><br><span class="line">		public DownloadThread(File file, URL url, int start, int end) &#123;</span><br><span class="line">			this.file = file;</span><br><span class="line">			this.url = url;</span><br><span class="line">			this.start = start;</span><br><span class="line">			this.end = end;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			InputStream is = null;</span><br><span class="line">			RandomAccessFile raf = null;</span><br><span class="line">			try &#123;</span><br><span class="line">				HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">				conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + start + &quot;-&quot; + end);</span><br><span class="line">				is = conn.getInputStream();</span><br><span class="line">				raf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">				raf.seek(start);</span><br><span class="line">				byte[] bytes = new byte[1024];</span><br><span class="line">				int len;</span><br><span class="line">				while ((len = is.read(bytes)) != -1) &#123;</span><br><span class="line">					raf.write(bytes, 0, len);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; finally &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					raf.close();</span><br><span class="line">					is.close();</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				checkFinish(++count);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void checkFinish(int count) &#123;</span><br><span class="line">			if (count == THREAD_NUM) &#123;</span><br><span class="line">				endTime = System.currentTimeMillis();</span><br><span class="line">				usetime = (endTime - startTime) / 1000.0;</span><br><span class="line">				System.out.println(&quot;下载用时为：&quot; + usetime + &quot;s&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事不宜迟，我们赶紧把demo跑起来，先尝试一下用单线程下载网易云音乐apk文件的用时。</p>
<p><img src="/images/7/usetime1.png" alt="usetime"></p>
<p>接着用3个线程来下载看看。</p>
<p><img src="/images/7/usetime2.png" alt="usetime"></p>
<p>速度果然有所提升，快了大约4秒。</p>
<p>那么换成10个进程进行下载呢？</p>
<p><img src="/images/7/usetime3.png" alt="usetime"></p>
<p>速度仍有提升，但是提升已经不大了。</p>
<hr>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>接下来我们就用多线程下载来下载一下服务器上的图片文件，看看速度是否有所提升，我们把url换成图片url。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final String PICTURE_URL = &quot;http://101.132.185.255:8080/resource/fightpicture/gallery/QQ%E5%9B%BE%E7%89%8720180330214156.gif&quot;;</span><br></pre></td></tr></table></figure></p>
<p>demo运行结果：</p>
<p><img src="/images/7/usetime4.png" alt="usetime"></p>
<p>结果显示，1.8M的gif图片，仍然下载了约13秒，与之前单线程下载如出一辙。</p>
<hr>
<h1 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h1><p>前面通过下载网易云音乐apk文件的例子，我们知道了40M左右的文件10秒内就下载完毕了，这么来说，java性能的原因就可以直接被排除了，那么很显然，多半是服务器的速度问题。首先服务器的带宽应该不成问题，我在服务器上下载文件速度可以达到10M/S，那么多半就是tomcat的性能问题了，或许是tomcat用作静态文件服务器表现并不好。我尝试把apk文件放在了tomcat下,通过浏览器url直接去下载。</p>
<p><img src="/images/7/download.png" alt="download"></p>
<p>果然，速度维持在140KB/S左右，与我们下载gif图片的速度如出一辙。</p>
<hr>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>tomcat作为文件服务器的表现性能不佳，这点我本该早点预料到。通过百度，我了解到一般通过云存储+CDN加速的方案托管我们的静态资源，例如阿里云的OSS，才能让文件下载速度真正提升上去。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/04/04/java BufferedOutputStream的骗局/">java BufferedOutputStream的骗局</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/技术/">技术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><p>文章的开始，先从一个案例谈起。<br>最近在做的项目中有图片保存的需求，之前一律按jpg格式处理了，今天想想不妥，于是适配了所有的图片格式。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">    int length;</span><br><span class="line">    byte[] bytes = new byte[10240];</span><br><span class="line">    while((length = is.read(bytes, 0, 10240)) != -1) &#123;</span><br><span class="line">        fos.write(bytes, 0, length);</span><br><span class="line">    &#125;</span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目跑起来，试着保存了一张gif图片，显示成功，本以为大功告成，结果切到本地图片gallery一看，图片根本没有保存成功。正愣着呢，图片又突然出现了。我稍微一想，就知道是保存图片的速度过慢。输出看了下缓存图片的耗时。</p>
<p><img src="/images/6/usetime.png" alt="usetime"></p>
<p>2MB的gif图片足足缓存了十几秒，用户体验想必是很差的，那么有没有办法加快缓存速度呢？我的java知识告诉我，有！使用BufferedOutputStream维护一个字节缓冲池以减少IO次数，提升缓存速度。于是我使用了BufferedOutputStream：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(fos);</span><br><span class="line">int length;</span><br><span class="line">byte[] bytes = new byte[10240];</span><br><span class="line">while((length = is.read(bytes, 0, 10240)) != -1) &#123;</span><br><span class="line">    bos.write(bytes, 0, length);</span><br><span class="line">&#125;</span><br><span class="line">bos.flush();</span><br><span class="line">bos.close();</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>
<p>这回跑起来肯定快了吧！结果：</p>
<p><img src="/images/6/usetime2.png" alt="usetime2"></p>
<p>根本没有变快嘛！怎么回事？难道我记错了？抱着疑惑，我打开了BufferedOutputStream源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">class BufferedOutputStream extends FilterOutputStream &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The internal buffer where data is stored.</span><br><span class="line">     */</span><br><span class="line">    protected byte buf[];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The number of valid bytes in the buffer. This value is always</span><br><span class="line">     * in the range &lt;tt&gt;0&lt;/tt&gt; through &lt;tt&gt;buf.length&lt;/tt&gt;; elements</span><br><span class="line">     * &lt;tt&gt;buf[0]&lt;/tt&gt; through &lt;tt&gt;buf[count-1]&lt;/tt&gt; contain valid</span><br><span class="line">     * byte data.</span><br><span class="line">     */</span><br><span class="line">    protected int count;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new buffered output stream to write data to the</span><br><span class="line">     * specified underlying output stream.</span><br><span class="line">     *</span><br><span class="line">     * @param   out   the underlying output stream.</span><br><span class="line">     */</span><br><span class="line">    public BufferedOutputStream(OutputStream out) &#123;</span><br><span class="line">        this(out, 8192);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new buffered output stream to write data to the</span><br><span class="line">     * specified underlying output stream with the specified buffer</span><br><span class="line">     * size.</span><br><span class="line">     *</span><br><span class="line">     * @param   out    the underlying output stream.</span><br><span class="line">     * @param   size   the buffer size.</span><br><span class="line">     * @exception IllegalArgumentException if size &amp;lt;= 0.</span><br><span class="line">     */</span><br><span class="line">    public BufferedOutputStream(OutputStream out, int size) &#123;</span><br><span class="line">        super(out);</span><br><span class="line">        if (size &lt;= 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = new byte[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Flush the internal buffer */</span><br><span class="line">    private void flushBuffer() throws IOException &#123;</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            out.write(buf, 0, count);</span><br><span class="line">            count = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Writes the specified byte to this buffered output stream.</span><br><span class="line">     *</span><br><span class="line">     * @param      b   the byte to be written.</span><br><span class="line">     * @exception  IOException  if an I/O error occurs.</span><br><span class="line">     */</span><br><span class="line">    public synchronized void write(int b) throws IOException &#123;</span><br><span class="line">        if (count &gt;= buf.length) &#123;</span><br><span class="line">            flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        buf[count++] = (byte)b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array</span><br><span class="line">     * starting at offset &lt;code&gt;off&lt;/code&gt; to this buffered output stream.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; Ordinarily this method stores bytes from the given array into this</span><br><span class="line">     * stream&apos;s buffer, flushing the buffer to the underlying output stream as</span><br><span class="line">     * needed.  If the requested length is at least as large as this stream&apos;s</span><br><span class="line">     * buffer, however, then this method will flush the buffer and write the</span><br><span class="line">     * bytes directly to the underlying output stream.  Thus redundant</span><br><span class="line">     * &lt;code&gt;BufferedOutputStream&lt;/code&gt;s will not copy data unnecessarily.</span><br><span class="line">     *</span><br><span class="line">     * @param      b     the data.</span><br><span class="line">     * @param      off   the start offset in the data.</span><br><span class="line">     * @param      len   the number of bytes to write.</span><br><span class="line">     * @exception  IOException  if an I/O error occurs.</span><br><span class="line">     */</span><br><span class="line">    public synchronized void write(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">        if (len &gt;= buf.length) &#123;</span><br><span class="line">            /* If the request length exceeds the size of the output buffer,</span><br><span class="line">               flush the output buffer and then write the data directly.</span><br><span class="line">               In this way buffered streams will cascade harmlessly. */</span><br><span class="line">            flushBuffer();</span><br><span class="line">            out.write(b, off, len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (len &gt; buf.length - count) &#123;</span><br><span class="line">            flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(b, off, buf, count, len);</span><br><span class="line">        count += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Flushes this buffered output stream. This forces any buffered</span><br><span class="line">     * output bytes to be written out to the underlying output stream.</span><br><span class="line">     *</span><br><span class="line">     * @exception  IOException  if an I/O error occurs.</span><br><span class="line">     * @see        java.io.FilterOutputStream#out</span><br><span class="line">     */</span><br><span class="line">    public synchronized void flush() throws IOException &#123;</span><br><span class="line">        flushBuffer();</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我没记错，BufferedOutputStream确实维护了一个byte数组，先往byte数组里面填充字节，当byte数组满了，再写出去。但是，如果不设置参数，缓冲池的大小只有8192byte，也就是说，我10240byte一次的写出大小反而增多了IO次数，也难怪速度没有提升。我试着加大了BufferedOutputStream的buffer大小：</p>
<p><code>BufferedOutputStream bos = new BufferedOutputStream(fos, 1000 * 1024);</code></p>
<p>结果：</p>
<p><img src="/images/6/usetime3.png" alt="usetime3"></p>
<p>速度还是没有提升，那么只有一种可能了，IO根本不是影响缓存速度的决定因素。或者说，这么点次数的IO不会是影响缓存速度的决定因素。为了证实我的猜想，我们试试看每次只读入写出1个字节，增多读入写出次数，增大IO开销：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">int data;</span><br><span class="line">while((data = is.read()) != -1) &#123;</span><br><span class="line">    fos.write(data);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/images/6/usetime4.png" alt="usetime4"></p>
<p>终于，在这种极端情况下，缓存图片的时间终于增长了！本来是费尽心机想减少缓存时间，现在竟然费尽心机想增长缓存时间！</p>
<p>既然IO不是影响缓存速度的决定因素，那么，使用BufferedOutputStream的意义似乎就不存在了。</p>
<p><strong>另外，如果想要减少IO次数，直接增大代码中的byte数组不就可以了吗，别忘了，我们使用read(bytes[], int, int)和write(bytes[], int, int)这种有别于无参数的read和一个参数的write方法，其实就是做了和BufferedOutputStream一样的工作——维护一个缓冲池。这么一看，BufferedOutputStream的存在意义，似乎也不存在了。</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/03/31/Android性能优化之ViewHolder&amp;convertView/">Android性能优化之ViewHolder&amp;convertView</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-03-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/技术/">技术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/android/">android</a></span><div class="content"><p>查阅了许多博客，对ViewHolder的优化原理仍然不明白，今天深入研究了一下，总算是理解了。<br>先贴上项目里使用的一个图片GridView的Adapter代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdapter extends BaseAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private LayoutInflater mInflater;</span><br><span class="line">    private Context context;</span><br><span class="line">    private List&lt;String&gt; pictureUrls;</span><br><span class="line"></span><br><span class="line">    public MyAdapter(Context context, List&lt;String&gt; pictures) &#123;</span><br><span class="line">        mInflater = LayoutInflater.from(context);</span><br><span class="line">        this.context = context;</span><br><span class="line">        this.pictureUrls = pictures;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">        ViewHolder viewHolder = null;</span><br><span class="line">        if (convertView == null) &#123;</span><br><span class="line">            convertView = mInflater.inflate(R.layout.picture_item_layout, parent, false);</span><br><span class="line">            viewHolder = new ViewHolder();</span><br><span class="line">            viewHolder.picture = convertView.findViewById(R.id.picture);</span><br><span class="line">            convertView.setTag(viewHolder);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            viewHolder = (ViewHolder) convertView.getTag();</span><br><span class="line">        &#125;</span><br><span class="line">        viewHolder.picture.setImageURI(getItem(position));</span><br><span class="line">        return convertView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return pictureUrls.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getItem(int position) &#123;</span><br><span class="line">        return pictureUrls.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getItemId(int position) &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class ViewHolder &#123;</span><br><span class="line">        SimpleDraweeView picture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他三个方法不用多说，关键在于getView方法。<br>getView方法用于返回item的View，我们看方法的参数convertView，通过查阅博客，我知道了convertView是android中Recycler构件缓存的View，当有item移出屏幕的时候，获取下一个item时调用的getView方法的convertView参数就是被移除的item的View，如下图：</p>
<p><img src="/images/5/Recycler.jpg" alt="Recycler"></p>
<p>至此都不难理解，这些预备知识我早先就知道了，却仍然不明白如何实现的性能优化。</p>
<p>苦思冥想后，恍然大悟，我不过是进入了一次思维误区：<br>从来没见过ViewHolder这种复用机制的我感觉太新鲜了，认为ViewHolder才是主角，convertView不过是个参数，小小配角而已，殊不知android如此大费周章编写的构件，怎么可能会给一个甚至没有加入SDK的自定义类抢去风头！实现性能优化的恰恰是convertView，ViewHolder不过是个添头。</p>
<p>不论是GridView还是ListView，它们的item都是从同一个layout中inflate的，所以说白了，我们接下来要生成的View，从组成上说，与convertView是一样的，唯一不同的就是其中填充的数据，复用convertView，就可以省下重新inflate的开销（这可是IO操作），达到提升性能的效果。</p>
<p>那么ViewHolder呢？它有什么用呢？要想解决这个问题，先回答另一个问题，ViewHolder中保存的是什么？以上面的代码为例，是SimpleDraweeView，也就是新View和convertView存在内容上不同的子控件，在getView方法里我们肯定要修改它的内容，那就肯定要获取到它，使用传统的findViewById也存在一定的时间开销，当要修改内容的控件增多时，开销会更大，所以使用ViewHolder通过View的setTag方法把控件保存起来，需要修改的时候再取出来，可以省下一定的开销。也就是说，这是一种空间换时间的策略。</p>
<p>至此我们的问题解决了，不妨跟着例子的代码走一遍：</p>
<ol>
<li>GridView初始化，创建item，调用getView方法，此时convertView为空，我们通过LayoutInflater填充View赋给convertView，并创建ViewHolder绑定到View上（ViewHolder里面有我们获取到的SimpleDraweeView子控件），接着给SimpleDraweeView设置图片的URL（修改子控件内容），最后返回convertView。这个阶段会重复若干次，直到屏幕显示满图片。</li>
<li>下拉屏幕，获取新的item，此时创建item，调用getView方法，convertView就不为空了，我们直接拿到ViewHolder并修改其中子控件的内容，此时这个被回收的convertView就摇身一变，变成了我们期望的新View了（图片URL被改变了），于是我们将它返回。</li>
</ol>
<p>最后满足一下我的好奇心~当GridView多个View被回收，又创建多个新View的时候，convertView会是怎么样对应的呢？<br>我们对上述例子代码修改SimpleDraweeView内容的一行注释掉，看看运行结果~</p>
<p><img src="/images/5/before.png" alt="before"></p>
<p><img src="/images/5/after.png" alt="after"></p>
<p>可以看出来，当下拉加载第一排图片的时候，第一张图片的convertView是下拉前的第一张图片，也就是第一个被回收的图片，第二三四张图片的convertView却是null，所以加载了正确的图片。接着下拉加载第二排的图片，第一二张图片的convertView是下拉前的第三四张图片，也就是最后回收的两张图片。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/03/27/H5 + Servlet3.0实现文件上传/">H5 + Servlet3.0实现文件上传</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-03-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/技术/">技术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/j2ee/">j2ee</a></span><div class="content"><p>在之前的项目中要实现文件上传功能时，我一般使用Apache的commons-fileupload组件，最近发现Servlet3.0提供了对文件上传的原生支持，API非常简洁易懂，总结一下使用方法。</p>
<ul>
<li>后端</li>
</ul>
<ol>
<li>使用注解@MultipartConfig将一个Servlet标识为支持文件上传，否则会报Unable to process parts as no multi-part configuration has been provided错误，这里使用了Servlet3.0的注解特性。</li>
<li>HttpServletRequest提供了getPart和getParts两个方法获取到表单的内容。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//getPart方法</span><br><span class="line">Part image = null;</span><br><span class="line">      InputStream imageInputStream = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          image = request.getPart(&quot;image&quot;);</span><br><span class="line">          if (image != null &amp;&amp; image.getSize() != 0)</span><br><span class="line">              imageInputStream = image.getInputStream();</span><br><span class="line">       FileUtils.copyInputStreamToFile(imageInputStream, new File(targetFile));//common-io包提供的写文件API</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>getPart方法根据表单的name属性获取表单内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//getParts方法</span><br><span class="line">ArrayList&lt;Part&gt; images;</span><br><span class="line">      try &#123;</span><br><span class="line">          images = (ArrayList&lt;Part&gt;) request.getParts();</span><br><span class="line">          count = images.size();</span><br><span class="line">          for (Part image : images) &#123;</span><br><span class="line">              InputStream imageInputStream = null;</span><br><span class="line">              imageInputStream = image.getInputStream();</span><br><span class="line">		FileUtils.copyInputStreamToFile(imageInputStream, new File(targetFile));</span><br><span class="line">	&#125;</span><br><span class="line">      &#125; catch (IOException e1) &#123;</span><br><span class="line">          e1.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>getParts则获取到表单中的全部内容。</p>
<ul>
<li>前端</li>
</ul>
<p>创建一个FormData对象，由于参数为表单的DOM对象，所以用JQuery选择器获取后应转换为DOM对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">             type: &apos;post&apos;,</span><br><span class="line">             url: &apos;updateAvatar.action&apos;,</span><br><span class="line">             data: new FormData($(&apos;#form&apos;)[0]),</span><br><span class="line">             processData: false,</span><br><span class="line">             contentType: false,</span><br><span class="line">             success: function(data) &#123;</span><br><span class="line">                 </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/12/07/ES5&amp;JQuery数组遍历/">ES5&amp;JQuery数组遍历</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-12-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/技术/">技术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/javascript/">javascript</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/jQuery/">jQuery</a></span><div class="content"><p>ES5 forEach</p>
<p>1.不支持IE9之前的版本。<br>2.匿名函数中的this都是指Window。<br>3.只能遍历数组。<br>4.没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ary = [12,23,24,42,1]; </span><br><span class="line">var res = ary.forEach(function (value,index,array) &#123; </span><br><span class="line">array[index] = value*10; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);//--&gt; undefined; </span><br><span class="line">console.log(ary);//--&gt; 通过数组索引改变了原数组</span><br></pre></td></tr></table></figure>
<p>ES5 map</p>
<p>1.不支持IE9之前的版本。<br>2.匿名函数中的this都是指Window。<br>3.只能遍历数组。<br>4.返回一个新的数组，原数组不变。map的回调函数中支持return返回值；return的是啥，相当于把数组中的这一项变为啥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ary = [12,23,24,42,1]; </span><br><span class="line">var res = ary.map(function (value,index,array) &#123; </span><br><span class="line">return item*10; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);//--&gt;[120,230,240,420,10];原数组拷贝了一份，并进行了修改</span><br><span class="line">console.log(ary);//--&gt;[12,23,24,42,1];原数组并未发生变化</span><br></pre></td></tr></table></figure>
<p>JQuery $.each</p>
<p>1.与ES5 forEach类似，但是第一二两个参数相反。<br>2.支持IE9之前版本。<br>3.能遍历数组和类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.each( [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], function(i, v)&#123; </span><br><span class="line">alert( i + &quot;: &quot; + v ); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">$.each( &#123; name: &quot;John&quot;, lang: &quot;JS&quot; &#125;, function(k, v)&#123; </span><br><span class="line">alert( &quot;Name: &quot; + k + &quot;, Value: &quot; + v ); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>JQuery $.map</p>
<p>1.与ES5 map类似，但是第一二两个参数相反。<br>2.支持IE9之前版本。<br>3.能遍历数组和类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr=$.map( [0,1,2], function(v)&#123; </span><br><span class="line">return v + 4; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">$.map(&#123;&quot;name&quot;:&quot;Jim&quot;,&quot;age&quot;:17&#125;,function(k, v)&#123; </span><br><span class="line">console.log( k+&quot;:&quot;+v ); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>再纠正个认知错误：each方法是JQuery对象的方法，对JQuery对象数组进行遍历，this指向该DOM对象，同理也有JQuery对象的map方法。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://sotama.cool/picture)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By feng</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>