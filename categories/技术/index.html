<!DOCTYPE html>
<html>

<head>
  
  <title>分类：技术 - 冯京哲的狗窝</title>
  <meta charset="UTF-8">
  <meta name="description" content="feng&#39;s blog">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta name="description" content="feng&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="冯京哲的狗窝">
<meta property="og:url" content="http://www.fengjingzhe.com/categories/技术/index.html">
<meta property="og:site_name" content="冯京哲的狗窝">
<meta property="og:description" content="feng&apos;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="冯京哲的狗窝">
<meta name="twitter:description" content="feng&apos;s blog">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="/css/style.css?v=1565793202749">
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/bg.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="feng" class="mdui-btn mdui-btn-icon"><img src="/images/avatar.jpg"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="feng">
            <img src="/images/avatar.jpg" alt="feng">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>31</div>
        <div><span>标签</span>11</div>
        <div><span>分类</span>3</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/7822981" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/fjz97/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/配置/">配置</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div class="nexmoe-widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/j2ee/" style="font-size: 14px;">j2ee</a> <a href="/tags/jQuery/" style="font-size: 16px;">jQuery</a> <a href="/tags/java/" style="font-size: 18px;">java</a> <a href="/tags/javascript/" style="font-size: 12px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul>
    </div>
  </div>


  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2019 feng
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts" id="brand-waterfall">
    
    <div class="nexmoe-post">
        <a href="/2019/07/14/与或操作处理状态码/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="与或操作处理状态码">
                
                <h1>与或操作处理状态码</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年07月14日</a>
            <a><i class="nexmoefont icon-areachart"></i>229 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/android/">android</a>
            
        </div>
        <article>
            
            <p>当状态码有叠加态的时候，可以用与或操作去处理。<br>当左右的值分别是2的次方且不相同的时候，或操作表示相加。<br>1 | 2 = 3<br>1 | 2 | 4 = 7<br>1 | 4 = 5<br>这个不难理解，2的次方bit码最高位为1，其余为0，如果左右的值不同，进行或操作后，会把两个最高位都置为1，即相加。<br>当左值为2的次方叠加，右值为2的次方时，与操作可以用来判断右值是否是左值的加数，当右值为左值加数时，结果是右值，否则是0。<br>15 &amp; 1 = 1<br>15 &amp; 2 = 2<br>15 &amp; 4 = 4<br>15 &amp; 8 = 8<br>15 &amp; 16 = 0<br>这个同理也不难理解。<br>于是可以这样处理状态码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int state;</span><br><span class="line">public static final int STATE_1 = 1;</span><br><span class="line">public static final int STATE_2 = 2;</span><br><span class="line">public static final int STATE_3 = 4;</span><br><span class="line"></span><br><span class="line">//set</span><br><span class="line">state = STATE_1 | STATE_2 | STATE_3;</span><br><span class="line"></span><br><span class="line">//get </span><br><span class="line">if ((state &amp; STATE_1) == STATE_1) &#123;</span><br><span class="line">	//state include STATE_1</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/05/18/MVVM初体验/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="MVVM初体验">
                
                <h1>MVVM初体验</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年05月18日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/Android/">Android</a>
            
        </div>
        <article>
            
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网上关于MVVM的文章很多了，本文站在一个初学者的角度，从实践出发，讲一下我对MVVM的理解和体验，如有误，待勘验。</p>
<hr>
<h3 id="为什么要使用MVVM"><a href="#为什么要使用MVVM" class="headerlink" title="为什么要使用MVVM"></a>为什么要使用MVVM</h3><p>为什么要使用MVVM？最关键的，就是解耦，MVVM将项目分成View、ViewModel、Model三层，各层完成不同的工作，使逻辑更加独立清晰，大大方便了维护和测试。MVVM与MVP有何不同？<br><img src="http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvp.png" alt="MVP"><img src="http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvvm.png" alt="MVVM"><br>看图，MVP的View和Presenter双向依赖，而MVVM的View和ViewModel是单向依赖的，ViewModel持有View，View却不持有ViewModel，更进一步降低了耦合。如何实现View和ViewModel的单向依赖？有两种方法，一种是通过Google官方的DataBinding机制，这是一种数据驱动的思想，类似Vue，另一种是使用RxJava，这是一种事件驱动的思想，类似RxBus，本文使用RxJava作为解决方案。</p>
<hr>
<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>在着手代码前，我有必要先讲一下RxJava。这是我第一次使用RxJava，其实直到现在，我对于它还是一知半解，我希望用通俗的语言介绍一下它，尽管很可能不正确。<br>首先，要知道的是，RxJava最核心的思想是异步，实现的方式是观察者模式，Observable类对应了被观察者，Observer类对应了观察者。当被观察者和观察者被创建后，调用Observable.subscribe(Observer)即完成订阅，订阅即触发，Observable开始执行耗时操作，当操作完成后，通知Observer进行回调。这是最基本的异步使用方法，即使不用RxJava，我们也可以用Message-Handler去实现。但我不想用这种角度去看待Observable和Observer，在我看来，Observable是数据源，Observer是数据消费者。<br>接下来，要说的是Subject类，Subject有点特殊，它既是Observable，又是Observer，也就是说，它既可以生产数据，又可以消费数据。<br>最后再简单提一下CompositeDisposable这个类，Observable在调用subscribe方法后，会返回一个Disposable类，用于取消订阅，CompositeDisposable顾名思义可以对Disposable进行统一管理，当想要取消订阅的时候，调用CompositeDisposable.clear()就可以了。<br>以上就是项目中用到的所有RxJava提供的类。</p>
<hr>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>直接上手代码，本文代码完全参考了<a href="https://github.com/onlynight/V2EX" target="_blank" rel="noopener">这个项目</a>，为了使代码更加简洁，我只创建了三个类，分别对应了View、ViewModel、Model，并省去了一些生命周期方法，在实际的开发中，需要做一定的封装，并做好生命周期控制。</p>
<p>先看Model类，Model类比较简单，主要负责从网络或数据库获取数据，这里模拟一下从网络获取数据，返回一个Observable类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Model &#123;</span><br><span class="line">    //模拟从服务器获取数据</span><br><span class="line">    public Observable&lt;List&lt;String&gt;&gt; getData() &#123;</span><br><span class="line">        return Observable.create((emitter) -&gt; &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">            list.add(String.valueOf(System.currentTimeMillis()));</span><br><span class="line">            emitter.onNext(list);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是ViewModel类，ViewModel类持有一个Subject，作为数据消费者，通过bindData方法，将其与Model获取到的数据进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ViewModel &#123;</span><br><span class="line"></span><br><span class="line">    private CompositeDisposable compositeDisposable = new CompositeDisposable();</span><br><span class="line"></span><br><span class="line">    private Model model = new Model();</span><br><span class="line"></span><br><span class="line">    private PublishSubject&lt;List&lt;String&gt;&gt; data = PublishSubject.create();</span><br><span class="line"></span><br><span class="line">    private &lt;T&gt; void bindData(Observable&lt;List&lt;T&gt;&gt; observable, PublishSubject&lt;List&lt;T&gt;&gt; subject) &#123;</span><br><span class="line">        compositeDisposable.add(observable.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(subject::onNext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getUpdateData() &#123;</span><br><span class="line">        bindData(model.getData(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PublishSubject&lt;List&lt;String&gt;&gt; getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是View，View也有bindData方法，它将ViewModel中获得到的Subject（这里成为了数据源）与一个消费方法绑定，这样，每当数据源发生改变了后，消费方法就会被调用。这里值得一提的是，View和ViewModel都有bindData方法，它们在实现上是一样的，具体的效果却有所不同，View的bindData方法确实如同名字一样，将生产者和消费者进行了绑定，但是ViewModel的bindData只是让Subject获取了数据，并没有进行绑定，因为Model每次生产的数据源引用的不是同一个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private ListViewAdapter adapter;</span><br><span class="line"></span><br><span class="line">    private CompositeDisposable compositeDisposable = new CompositeDisposable();</span><br><span class="line"></span><br><span class="line">    private ViewModel viewModel = new ViewModel();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button = findViewById(R.id.button);</span><br><span class="line">        ListView listView = findViewById(R.id.list_view);</span><br><span class="line"></span><br><span class="line">        adapter = new ListViewAdapter(this);</span><br><span class="line">        listView.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">        bindData(viewModel.getData(), this::updateData);</span><br><span class="line">        button.setOnClickListener((v) -&gt; &#123;</span><br><span class="line">            viewModel.getUpdateData();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private &lt;T&gt; void bindData(Subject&lt;T&gt; subject, Consumer&lt;? super T&gt; consumer) &#123;</span><br><span class="line">        compositeDisposable.add(subject.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(consumer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void updateData(List&lt;String&gt; data) &#123;</span><br><span class="line">        swipeRefreshLayout.setRefreshing(false);</span><br><span class="line">        adapter.setData(data);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>综上，我们是通过这种观察者模式实现的View与ViewModel解耦，实现的关键在于Subject，它可以同时作为数据的生产者和消费者，它存在于ViewModel中，一方面从Model中获取数据，一方面当数据变化时通知View进行操作。<br><a href="https://github.com/fjz97/MVVMDemo" target="_blank" rel="noopener">源码</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/03/20/从哔哩哔哩漫画开始说起/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="从哔哩哔哩漫画开始说起">
                
                <h1>从哔哩哔哩漫画开始说起</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年03月20日</a>
            <a><i class="nexmoefont icon-areachart"></i>814 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 3 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/android/">android</a>
            
        </div>
        <article>
            
            <p>下了个哔哩哔哩漫画用来追五等分的花嫁。今早躺在床上，无意间点到了评分按钮，直接跳转到了锤子应用商店，把我吓了一跳。<br>出于职业病，我琢磨了一下实现原理。这并不难，我们知道Android存在隐式Intent机制，通过设置Action、Data、Category属性，可以选择合适的Activity打开。以打开浏览器为例，下面的代码可以打开浏览器，如果系统中存在多个可被第三方程序打开的浏览器，那么选择权会被移交给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_VIEW);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>根据这个原理，一定存在一个和应用商店相关的Action，它就是通过这个Action打开了我的应用商店，由于我系统里只有默认的锤子应用商店，所以它被直接打开了。为了验证我的猜想，我安装了豌豆荚，再次回到哔哩哔哩漫画，点击评分按钮，果然出现了选择应用选项。<br><img src="/images/29/choose_app.png" alt="choose_app"><br>到此为止，除了再一次感叹隐式Intent这种过滤思想的精妙之外，没有任何问题。问题在于，即使应用商店声明了自己接收这种隐式意图，处于非活动状态的它又是怎么知道有应用发出了这种意图的呢？<br>我的第一个想法是通过Service，监听这种意图，这条思路很清晰，但是很快就被我否决了。且不说Service占用资源且容易被杀死，就从实现原理来讲可能性也不大，我可没听说过startActivity方法被调用以后，会发出什么可以被监听到的广播或者其它什么的信息，就算有，它应该也是处于底层的，不是留给开发者处理的，而且就我自己的回忆，当初学习隐式Intent的时候似乎写过类似功能的Demo，并没有涉及到Service，只是在intent-filter里声明了相关的Action，就可以被其它的应用打开。<br>基于上面的考量，选择合适的应用打开，应该是系统完成的事，那么第一个问题被解决了，不是应用主动获知有自己监听的Intent，而是Android系统通知它并唤醒它的。其实通过另外一点也可以推出这个结论：选择应用的对话框，明显不属于打开和被打开的两方应用，肯定是系统层级的。<br>那么第二个问题出来了：Android系统是如何知道哪些应用监听了这些Intent呢？这个问题解决起来思路就极其明确了，Activity通过intent-filter声明自己监听的Intent，而这些内容全被注册在了Manifest.xml文件里了，Android系统手握所有应用的Manifest.xml，自然可以查出哪个应用哪个Activity监听了哪个Intent，就可以轻易的调出相关应用了。<br>查阅了官方文档关于Manifest.xml的解释，官方文档说的清清楚楚，甚至把Intent过滤器拿出来做了个小标题。<a href="https://developer.android.google.cn/guide/topics/manifest/manifest-intro.html" target="_blank" rel="noopener">应用清单 | Android Developers</a></p>
<p>脸红~ 还是滚去学习了~</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/05/21/Android自定义Preference/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="Android自定义Preference">
                
                <h1>Android自定义Preference</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年05月21日</a>
            <a><i class="nexmoefont icon-areachart"></i>1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/android/">android</a>
            
        </div>
        <article>
            
            <p>在写设置时参考了EH，发现使用了Preference类，它帮我们自动实现了ListView，只需要编写一个xml文件就可以实现各种样式的设置项，并自动将设置项保存到SharedPreferences内，非常方便。具体可以参考这篇文章：<a href="https://www.cnblogs.com/valenhua/archive/2017/10/03/7624640.html" target="_blank" rel="noopener">Android Preference 设置偏好全攻略</a></p>
<p>这篇文章讲一下如何重写Preference，以实现自定义样式。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/05/16/java File返回什么路径/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="java File返回什么路径">
                
                <h1>java File返回什么路径</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年05月16日</a>
            <a><i class="nexmoefont icon-areachart"></i>803 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 3 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>Android7.0为了进一步加强私有文件的安全性，不再由开发者放宽私有文件的访问权限，这就意味着我们在代码中不能再随心所欲地操纵一些文件。</p>
<p>昨天在做更新app并打开安装包的时候，就报了FileUriExposedException 异常。经过百度，找到了解决的办法——使用FileProvider，<a href="https://www.jianshu.com/p/3f9e3fc38eae" target="_blank" rel="noopener">参考文章在这里</a>。照着文章使用了FileProvider后，却出现了解析程序包时出现问题。</p>
<p><img src="/images/26/problem.png" alt="解析程序包时出现问题"></p>
<p>查看log发现了如下的warning：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error staging apk from content URI: content://com.fengjingzhe.fightpicture.fileprovider/download/file%3A/storage/emulated/0/Android/data/com.fengjingzhe.fightpicture/files/Download/fightpicture-1.1.2.apk</span><br><span class="line">                                                     java.io.FileNotFoundException: No such file or directory</span><br></pre></td></tr></table></figure>
<p>也就是说，uri出了错误，系统找不到apk文件了。我赶紧查看生成uri的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri apkUri = FileProvider.getUriForFile(MainActivity.this, &quot;com.fengjingzhe.fightpicture.fileprovider&quot;, file);</span><br></pre></td></tr></table></figure>
<p>这个uri是通过官方的api生成的，网上也都是使用了这个方法，理应不会有错猜对啊！！！真是百思不得其解！！！</p>
<p>反复观察了这个生成的uri，我猜测问题出在了中间的<code>file%3A</code>上。抱着试一试的心态，我自己拼接了一下uri：</p>
<p><code>content://com.fengjingzhe.fightpicture.fileprovider/download/storage/emulated/0/Android/data/com.fengjingzhe.fightpicture/files/Download/fightpicture-1.1.2.apk</code></p>
<p>运行程序，居然成功了！成功打开了这个apk，进入安装界面。</p>
<p>那么为什么官方的api生成的uri出错了呢？我深入FileProvider源码仔细查看，看了大半个晚上，仍然没有找出猫腻，只能悻悻然会宿舍了。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>时间回到今天，我在测试<code>File.getAbsolutePath()</code>和<code>File.getPath()</code>两个方法返回的路径究竟有什么区别的时候，为了省事，直接在项目中找现成的File类进行测试，其中就包括了这个下载好的apk。这时，意料之外的情况发生了。我发现，不同的两个文件，就算是同一个<code>getPath()</code>方法，居然返回的路径格式大相径庭。比如，这个apk文件返回了这样一个路径：</p>
<p><code>file:/storage/emulated/0/Android/data/com.fengjingzhe.fightpicture/files/Download/fightpicture-1.1.2.apk</code></p>
<p>而一张图片文件返回了这样一个路径：</p>
<p><code>/storage/emulated/0/fightpicture/1526470886506.jpg</code></p>
<p>抱着疑问，我打开了File的源码，这里贴出关键部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   public File(String pathname) &#123;</span><br><span class="line">       if (pathname == null) &#123;</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       &#125;</span><br><span class="line">       //nomalize方法去除了头尾多余的斜杠</span><br><span class="line">       this.path = fs.normalize(pathname);</span><br><span class="line">       this.prefixLength = fs.prefixLength(this.path);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public String getPath() &#123;</span><br><span class="line">       return path;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，你的构造方法传什么样的路径，getPath()方法就会返回给你什么样的路径，而构造方法恰恰接受file:///和/开头的两种类型路径。</p>
<p>回到getUriForFile方法上来，之所以返回的uri多了一点东西，就是因为我们的apk文件的getPath方法返回的路径多了file:///的前缀。那么，我们在getUriForFile方法中给它传一个/前缀的文件，返回的uri是不是就正常了呢？我们改动代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(Uri.parse(filename).getEncodedPath());</span><br><span class="line">                    Uri apkUri = FileProvider.getUriForFile(MainActivity.this, &quot;com.fengjingzhe.fightpicture.fileprovider&quot;, file);</span><br></pre></td></tr></table></figure>
<p>果然，成功打开了apk文件，进入了安装界面。问题成功解决了。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/04/28/java多线程下载/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="java多线程下载">
                
                <h1>java多线程下载</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年04月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <p>在上一篇文章里，我们讨论了图片缓存速度慢的原因，发现IO并不是决定因素。那么问题出在哪呢？一篇关于java多线程下载的博客引起了我的注意：我们知道迅雷、旋风等下载器都是多线程下载的，会不会是单线程效率的问题影响了图片缓存速度呢？事不宜迟，我们开始验证。</p>
<hr>
<h1 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h1><p>多线程下载的原理很简单，无非就是分段请求数据，最后再把每段数据拼凑起来，实现起来需要解决两个问题， 没错，就是怎么分段请求和怎么拼接数据。</p>
<h2 id="1-HTTP-1-1-Header-Range"><a href="#1-HTTP-1-1-Header-Range" class="headerlink" title="1.HTTP/1.1 Header Range"></a>1.HTTP/1.1 Header Range</h2><p>首先面临的问题是，怎么分段请求数据。<br>HTTP/1.1引入了一个新的header，名字叫做Range，它可以指定一个范围，然后http请求就会只请求那一段的数据，java代码可以这样写：</p>
<p><code>conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + start + &quot;-&quot; + end);</code></p>
<p>其中start就是数据的开始字节，end是数据的结束字节。</p>
<h2 id="2-RandomAccessFile"><a href="#2-RandomAccessFile" class="headerlink" title="2.RandomAccessFile"></a>2.RandomAccessFile</h2><p>第二个问题是，怎么将这些分段的数据拼接起来。<br>这里我们需要用到java随机访问文件RandomAccessFile，它指定文件并通过seek方法跳转到该文件的任意字节处进行读写操作。于是我们的java代码可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">raf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">raf.seek(start);</span><br><span class="line">byte[] bytes = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = is.read(bytes)) != -1) &#123;</span><br><span class="line">	raf.write(bytes, 0, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便测试，我写了一个java demo，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	</span><br><span class="line">	private static final String PICTURE_URL = &quot;http://d1.music.126.net/dmusic/CloudMusic_official_5.1.0.573520.apk&quot;;</span><br><span class="line">	private static final String FILE_NAME = &quot;cloudmusic.apk&quot;;</span><br><span class="line">	private static final int THREAD_NUM = 10;</span><br><span class="line">	private static long startTime;</span><br><span class="line">	private static long endTime;</span><br><span class="line">	private static double usetime;</span><br><span class="line">	private static int count = 0;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		startTime = System.currentTimeMillis();</span><br><span class="line">		try &#123;</span><br><span class="line">			File file = new File(&quot;C:/cdt/&quot;, FILE_NAME);</span><br><span class="line">			URL url = new URL(PICTURE_URL);</span><br><span class="line">			HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">			int size = conn.getContentLength();</span><br><span class="line">			int piece = size % THREAD_NUM == 0 ? size / THREAD_NUM : (size / THREAD_NUM + 1);</span><br><span class="line">			for (int j = 0; j &lt; THREAD_NUM; j++) &#123;</span><br><span class="line">				int start = j * piece;</span><br><span class="line">				int end = (j + 1) * piece - 1;</span><br><span class="line">				if (j == THREAD_NUM - 1) end = size;</span><br><span class="line">				new DownloadThread(file, url, start, end).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static class DownloadThread extends Thread &#123;</span><br><span class="line">		private File file;</span><br><span class="line">		private URL url;</span><br><span class="line">		private int start;</span><br><span class="line">		private int end;</span><br><span class="line">		</span><br><span class="line">		public DownloadThread(File file, URL url, int start, int end) &#123;</span><br><span class="line">			this.file = file;</span><br><span class="line">			this.url = url;</span><br><span class="line">			this.start = start;</span><br><span class="line">			this.end = end;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			InputStream is = null;</span><br><span class="line">			RandomAccessFile raf = null;</span><br><span class="line">			try &#123;</span><br><span class="line">				HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">				conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + start + &quot;-&quot; + end);</span><br><span class="line">				is = conn.getInputStream();</span><br><span class="line">				raf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">				raf.seek(start);</span><br><span class="line">				byte[] bytes = new byte[1024];</span><br><span class="line">				int len;</span><br><span class="line">				while ((len = is.read(bytes)) != -1) &#123;</span><br><span class="line">					raf.write(bytes, 0, len);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; finally &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					raf.close();</span><br><span class="line">					is.close();</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				checkFinish(++count);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void checkFinish(int count) &#123;</span><br><span class="line">			if (count == THREAD_NUM) &#123;</span><br><span class="line">				endTime = System.currentTimeMillis();</span><br><span class="line">				usetime = (endTime - startTime) / 1000.0;</span><br><span class="line">				System.out.println(&quot;下载用时为：&quot; + usetime + &quot;s&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事不宜迟，我们赶紧把demo跑起来，先尝试一下用单线程下载网易云音乐apk文件的用时。</p>
<p><img src="/images/7/usetime1.png" alt="usetime"></p>
<p>接着用3个线程来下载看看。</p>
<p><img src="/images/7/usetime2.png" alt="usetime"></p>
<p>速度果然有所提升，快了大约4秒。</p>
<p>那么换成10个进程进行下载呢？</p>
<p><img src="/images/7/usetime3.png" alt="usetime"></p>
<p>速度仍有提升，但是提升已经不大了。</p>
<hr>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>接下来我们就用多线程下载来下载一下服务器上的图片文件，看看速度是否有所提升，我们把url换成图片url。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final String PICTURE_URL = &quot;http://101.132.185.255:8080/resource/fightpicture/gallery/QQ%E5%9B%BE%E7%89%8720180330214156.gif&quot;;</span><br></pre></td></tr></table></figure></p>
<p>demo运行结果：</p>
<p><img src="/images/7/usetime4.png" alt="usetime"></p>
<p>结果显示，1.8M的gif图片，仍然下载了约13秒，与之前单线程下载如出一辙。</p>
<hr>
<h1 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h1><p>前面通过下载网易云音乐apk文件的例子，我们知道了40M左右的文件10秒内就下载完毕了，这么来说，java性能的原因就可以直接被排除了，那么很显然，多半是服务器的速度问题。首先服务器的带宽应该不成问题，我在服务器上下载文件速度可以达到10M/S，那么多半就是tomcat的性能问题了，或许是tomcat用作静态文件服务器表现并不好。我尝试把apk文件放在了tomcat下,通过浏览器url直接去下载。</p>
<p><img src="/images/7/download.png" alt="download"></p>
<p>果然，速度维持在140KB/S左右，与我们下载gif图片的速度如出一辙。</p>
<hr>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>tomcat作为文件服务器的表现性能不佳，这点我本该早点预料到。通过百度，我了解到一般通过云存储+CDN加速的方案托管我们的静态资源，例如阿里云的OSS，才能让文件下载速度真正提升上去。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/04/04/java BufferedOutputStream的骗局/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="java BufferedOutputStream的骗局">
                
                <h1>java BufferedOutputStream的骗局</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年04月04日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 6 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <p>文章的开始，先从一个案例谈起。<br>最近在做的项目中有图片保存的需求，之前一律按jpg格式处理了，今天想想不妥，于是适配了所有的图片格式。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">    int length;</span><br><span class="line">    byte[] bytes = new byte[10240];</span><br><span class="line">    while((length = is.read(bytes, 0, 10240)) != -1) &#123;</span><br><span class="line">        fos.write(bytes, 0, length);</span><br><span class="line">    &#125;</span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目跑起来，试着保存了一张gif图片，显示成功，本以为大功告成，结果切到本地图片gallery一看，图片根本没有保存成功。正愣着呢，图片又突然出现了。我稍微一想，就知道是保存图片的速度过慢。输出看了下缓存图片的耗时。</p>
<p><img src="/images/6/usetime.png" alt="usetime"></p>
<p>2MB的gif图片足足缓存了十几秒，用户体验想必是很差的，那么有没有办法加快缓存速度呢？我的java知识告诉我，有！使用BufferedOutputStream维护一个字节缓冲池以减少IO次数，提升缓存速度。于是我使用了BufferedOutputStream：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(fos);</span><br><span class="line">int length;</span><br><span class="line">byte[] bytes = new byte[10240];</span><br><span class="line">while((length = is.read(bytes, 0, 10240)) != -1) &#123;</span><br><span class="line">    bos.write(bytes, 0, length);</span><br><span class="line">&#125;</span><br><span class="line">bos.flush();</span><br><span class="line">bos.close();</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>
<p>这回跑起来肯定快了吧！结果：</p>
<p><img src="/images/6/usetime2.png" alt="usetime2"></p>
<p>根本没有变快嘛！怎么回事？难道我记错了？抱着疑惑，我打开了BufferedOutputStream源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">class BufferedOutputStream extends FilterOutputStream &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The internal buffer where data is stored.</span><br><span class="line">     */</span><br><span class="line">    protected byte buf[];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The number of valid bytes in the buffer. This value is always</span><br><span class="line">     * in the range &lt;tt&gt;0&lt;/tt&gt; through &lt;tt&gt;buf.length&lt;/tt&gt;; elements</span><br><span class="line">     * &lt;tt&gt;buf[0]&lt;/tt&gt; through &lt;tt&gt;buf[count-1]&lt;/tt&gt; contain valid</span><br><span class="line">     * byte data.</span><br><span class="line">     */</span><br><span class="line">    protected int count;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new buffered output stream to write data to the</span><br><span class="line">     * specified underlying output stream.</span><br><span class="line">     *</span><br><span class="line">     * @param   out   the underlying output stream.</span><br><span class="line">     */</span><br><span class="line">    public BufferedOutputStream(OutputStream out) &#123;</span><br><span class="line">        this(out, 8192);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new buffered output stream to write data to the</span><br><span class="line">     * specified underlying output stream with the specified buffer</span><br><span class="line">     * size.</span><br><span class="line">     *</span><br><span class="line">     * @param   out    the underlying output stream.</span><br><span class="line">     * @param   size   the buffer size.</span><br><span class="line">     * @exception IllegalArgumentException if size &amp;lt;= 0.</span><br><span class="line">     */</span><br><span class="line">    public BufferedOutputStream(OutputStream out, int size) &#123;</span><br><span class="line">        super(out);</span><br><span class="line">        if (size &lt;= 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = new byte[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Flush the internal buffer */</span><br><span class="line">    private void flushBuffer() throws IOException &#123;</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            out.write(buf, 0, count);</span><br><span class="line">            count = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Writes the specified byte to this buffered output stream.</span><br><span class="line">     *</span><br><span class="line">     * @param      b   the byte to be written.</span><br><span class="line">     * @exception  IOException  if an I/O error occurs.</span><br><span class="line">     */</span><br><span class="line">    public synchronized void write(int b) throws IOException &#123;</span><br><span class="line">        if (count &gt;= buf.length) &#123;</span><br><span class="line">            flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        buf[count++] = (byte)b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array</span><br><span class="line">     * starting at offset &lt;code&gt;off&lt;/code&gt; to this buffered output stream.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; Ordinarily this method stores bytes from the given array into this</span><br><span class="line">     * stream&apos;s buffer, flushing the buffer to the underlying output stream as</span><br><span class="line">     * needed.  If the requested length is at least as large as this stream&apos;s</span><br><span class="line">     * buffer, however, then this method will flush the buffer and write the</span><br><span class="line">     * bytes directly to the underlying output stream.  Thus redundant</span><br><span class="line">     * &lt;code&gt;BufferedOutputStream&lt;/code&gt;s will not copy data unnecessarily.</span><br><span class="line">     *</span><br><span class="line">     * @param      b     the data.</span><br><span class="line">     * @param      off   the start offset in the data.</span><br><span class="line">     * @param      len   the number of bytes to write.</span><br><span class="line">     * @exception  IOException  if an I/O error occurs.</span><br><span class="line">     */</span><br><span class="line">    public synchronized void write(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">        if (len &gt;= buf.length) &#123;</span><br><span class="line">            /* If the request length exceeds the size of the output buffer,</span><br><span class="line">               flush the output buffer and then write the data directly.</span><br><span class="line">               In this way buffered streams will cascade harmlessly. */</span><br><span class="line">            flushBuffer();</span><br><span class="line">            out.write(b, off, len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (len &gt; buf.length - count) &#123;</span><br><span class="line">            flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(b, off, buf, count, len);</span><br><span class="line">        count += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Flushes this buffered output stream. This forces any buffered</span><br><span class="line">     * output bytes to be written out to the underlying output stream.</span><br><span class="line">     *</span><br><span class="line">     * @exception  IOException  if an I/O error occurs.</span><br><span class="line">     * @see        java.io.FilterOutputStream#out</span><br><span class="line">     */</span><br><span class="line">    public synchronized void flush() throws IOException &#123;</span><br><span class="line">        flushBuffer();</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我没记错，BufferedOutputStream确实维护了一个byte数组，先往byte数组里面填充字节，当byte数组满了，再写出去。但是，如果不设置参数，缓冲池的大小只有8192byte，也就是说，我10240byte一次的写出大小反而增多了IO次数，也难怪速度没有提升。我试着加大了BufferedOutputStream的buffer大小：</p>
<p><code>BufferedOutputStream bos = new BufferedOutputStream(fos, 1000 * 1024);</code></p>
<p>结果：</p>
<p><img src="/images/6/usetime3.png" alt="usetime3"></p>
<p>速度还是没有提升，那么只有一种可能了，IO根本不是影响缓存速度的决定因素。或者说，这么点次数的IO不会是影响缓存速度的决定因素。为了证实我的猜想，我们试试看每次只读入写出1个字节，增多读入写出次数，增大IO开销：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">int data;</span><br><span class="line">while((data = is.read()) != -1) &#123;</span><br><span class="line">    fos.write(data);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/images/6/usetime4.png" alt="usetime4"></p>
<p>终于，在这种极端情况下，缓存图片的时间终于增长了！本来是费尽心机想减少缓存时间，现在竟然费尽心机想增长缓存时间！</p>
<p>既然IO不是影响缓存速度的决定因素，那么，使用BufferedOutputStream的意义似乎就不存在了。</p>
<p><strong>另外，如果想要减少IO次数，直接增大代码中的byte数组不就可以了吗，别忘了，我们使用read(bytes[], int, int)和write(bytes[], int, int)这种有别于无参数的read和一个参数的write方法，其实就是做了和BufferedOutputStream一样的工作——维护一个缓冲池。这么一看，BufferedOutputStream的存在意义，似乎也不存在了。</strong></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/03/31/Android性能优化之ViewHolder&convertView/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="Android性能优化之ViewHolder&amp;convertView">
                
                <h1>Android性能优化之ViewHolder&amp;convertView</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年03月31日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 4 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/android/">android</a>
            
        </div>
        <article>
            
            <p>查阅了许多博客，对ViewHolder的优化原理仍然不明白，今天深入研究了一下，总算是理解了。<br>先贴上项目里使用的一个图片GridView的Adapter代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdapter extends BaseAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private LayoutInflater mInflater;</span><br><span class="line">    private Context context;</span><br><span class="line">    private List&lt;String&gt; pictureUrls;</span><br><span class="line"></span><br><span class="line">    public MyAdapter(Context context, List&lt;String&gt; pictures) &#123;</span><br><span class="line">        mInflater = LayoutInflater.from(context);</span><br><span class="line">        this.context = context;</span><br><span class="line">        this.pictureUrls = pictures;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">        ViewHolder viewHolder = null;</span><br><span class="line">        if (convertView == null) &#123;</span><br><span class="line">            convertView = mInflater.inflate(R.layout.picture_item_layout, parent, false);</span><br><span class="line">            viewHolder = new ViewHolder();</span><br><span class="line">            viewHolder.picture = convertView.findViewById(R.id.picture);</span><br><span class="line">            convertView.setTag(viewHolder);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            viewHolder = (ViewHolder) convertView.getTag();</span><br><span class="line">        &#125;</span><br><span class="line">        viewHolder.picture.setImageURI(getItem(position));</span><br><span class="line">        return convertView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return pictureUrls.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getItem(int position) &#123;</span><br><span class="line">        return pictureUrls.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getItemId(int position) &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class ViewHolder &#123;</span><br><span class="line">        SimpleDraweeView picture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他三个方法不用多说，关键在于getView方法。<br>getView方法用于返回item的View，我们看方法的参数convertView，通过查阅博客，我知道了convertView是android中Recycler构件缓存的View，当有item移出屏幕的时候，获取下一个item时调用的getView方法的convertView参数就是被移除的item的View，如下图：</p>
<p><img src="/images/5/Recycler.jpg" alt="Recycler"></p>
<p>至此都不难理解，这些预备知识我早先就知道了，却仍然不明白如何实现的性能优化。</p>
<p>苦思冥想后，恍然大悟，我不过是进入了一次思维误区：<br>从来没见过ViewHolder这种复用机制的我感觉太新鲜了，认为ViewHolder才是主角，convertView不过是个参数，小小配角而已，殊不知android如此大费周章编写的构件，怎么可能会给一个甚至没有加入SDK的自定义类抢去风头！实现性能优化的恰恰是convertView，ViewHolder不过是个添头。</p>
<p>不论是GridView还是ListView，它们的item都是从同一个layout中inflate的，所以说白了，我们接下来要生成的View，从组成上说，与convertView是一样的，唯一不同的就是其中填充的数据，复用convertView，就可以省下重新inflate的开销（这可是IO操作），达到提升性能的效果。</p>
<p>那么ViewHolder呢？它有什么用呢？要想解决这个问题，先回答另一个问题，ViewHolder中保存的是什么？以上面的代码为例，是SimpleDraweeView，也就是新View和convertView存在内容上不同的子控件，在getView方法里我们肯定要修改它的内容，那就肯定要获取到它，使用传统的findViewById也存在一定的时间开销，当要修改内容的控件增多时，开销会更大，所以使用ViewHolder通过View的setTag方法把控件保存起来，需要修改的时候再取出来，可以省下一定的开销。也就是说，这是一种空间换时间的策略。</p>
<p>至此我们的问题解决了，不妨跟着例子的代码走一遍：</p>
<ol>
<li>GridView初始化，创建item，调用getView方法，此时convertView为空，我们通过LayoutInflater填充View赋给convertView，并创建ViewHolder绑定到View上（ViewHolder里面有我们获取到的SimpleDraweeView子控件），接着给SimpleDraweeView设置图片的URL（修改子控件内容），最后返回convertView。这个阶段会重复若干次，直到屏幕显示满图片。</li>
<li>下拉屏幕，获取新的item，此时创建item，调用getView方法，convertView就不为空了，我们直接拿到ViewHolder并修改其中子控件的内容，此时这个被回收的convertView就摇身一变，变成了我们期望的新View了（图片URL被改变了），于是我们将它返回。</li>
</ol>
<p>最后满足一下我的好奇心~当GridView多个View被回收，又创建多个新View的时候，convertView会是怎么样对应的呢？<br>我们对上述例子代码修改SimpleDraweeView内容的一行注释掉，看看运行结果~</p>
<p><img src="/images/5/before.png" alt="before"></p>
<p><img src="/images/5/after.png" alt="after"></p>
<p>可以看出来，当下拉加载第一排图片的时候，第一张图片的convertView是下拉前的第一张图片，也就是第一个被回收的图片，第二三四张图片的convertView却是null，所以加载了正确的图片。接着下拉加载第二排的图片，第一二张图片的convertView是下拉前的第三四张图片，也就是最后回收的两张图片。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/03/27/H5 + Servlet3.0实现文件上传/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="H5 + Servlet3.0实现文件上传">
                
                <h1>H5 + Servlet3.0实现文件上传</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年03月27日</a>
            <a><i class="nexmoefont icon-areachart"></i>318 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/j2ee/">j2ee</a>
            
        </div>
        <article>
            
            <p>在之前的项目中要实现文件上传功能时，我一般使用Apache的commons-fileupload组件，最近发现Servlet3.0提供了对文件上传的原生支持，API非常简洁易懂，总结一下使用方法。</p>
<ul>
<li>后端</li>
</ul>
<ol>
<li>使用注解@MultipartConfig将一个Servlet标识为支持文件上传，否则会报Unable to process parts as no multi-part configuration has been provided错误，这里使用了Servlet3.0的注解特性。</li>
<li>HttpServletRequest提供了getPart和getParts两个方法获取到表单的内容。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//getPart方法</span><br><span class="line">Part image = null;</span><br><span class="line">      InputStream imageInputStream = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          image = request.getPart(&quot;image&quot;);</span><br><span class="line">          if (image != null &amp;&amp; image.getSize() != 0)</span><br><span class="line">              imageInputStream = image.getInputStream();</span><br><span class="line">       FileUtils.copyInputStreamToFile(imageInputStream, new File(targetFile));//common-io包提供的写文件API</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>getPart方法根据表单的name属性获取表单内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//getParts方法</span><br><span class="line">ArrayList&lt;Part&gt; images;</span><br><span class="line">      try &#123;</span><br><span class="line">          images = (ArrayList&lt;Part&gt;) request.getParts();</span><br><span class="line">          count = images.size();</span><br><span class="line">          for (Part image : images) &#123;</span><br><span class="line">              InputStream imageInputStream = null;</span><br><span class="line">              imageInputStream = image.getInputStream();</span><br><span class="line">		FileUtils.copyInputStreamToFile(imageInputStream, new File(targetFile));</span><br><span class="line">	&#125;</span><br><span class="line">      &#125; catch (IOException e1) &#123;</span><br><span class="line">          e1.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>getParts则获取到表单中的全部内容。</p>
<ul>
<li>前端</li>
</ul>
<p>创建一个FormData对象，由于参数为表单的DOM对象，所以用JQuery选择器获取后应转换为DOM对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">             type: &apos;post&apos;,</span><br><span class="line">             url: &apos;updateAvatar.action&apos;,</span><br><span class="line">             data: new FormData($(&apos;#form&apos;)[0]),</span><br><span class="line">             processData: false,</span><br><span class="line">             contentType: false,</span><br><span class="line">             success: function(data) &#123;</span><br><span class="line">                 </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2017/12/07/ES5&JQuery数组遍历/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="ES5&amp;JQuery数组遍历">
                
                <h1>ES5&amp;JQuery数组遍历</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年12月07日</a>
            <a><i class="nexmoefont icon-areachart"></i>409 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/jQuery/">jQuery</a> <a class="nexmoefont icon-tag-fill -link" href="/tags/javascript/">javascript</a>
            
        </div>
        <article>
            
            <p>ES5 forEach</p>
<p>1.不支持IE9之前的版本。<br>2.匿名函数中的this都是指Window。<br>3.只能遍历数组。<br>4.没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ary = [12,23,24,42,1]; </span><br><span class="line">var res = ary.forEach(function (value,index,array) &#123; </span><br><span class="line">array[index] = value*10; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);//--&gt; undefined; </span><br><span class="line">console.log(ary);//--&gt; 通过数组索引改变了原数组</span><br></pre></td></tr></table></figure>
<p>ES5 map</p>
<p>1.不支持IE9之前的版本。<br>2.匿名函数中的this都是指Window。<br>3.只能遍历数组。<br>4.返回一个新的数组，原数组不变。map的回调函数中支持return返回值；return的是啥，相当于把数组中的这一项变为啥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ary = [12,23,24,42,1]; </span><br><span class="line">var res = ary.map(function (value,index,array) &#123; </span><br><span class="line">return item*10; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);//--&gt;[120,230,240,420,10];原数组拷贝了一份，并进行了修改</span><br><span class="line">console.log(ary);//--&gt;[12,23,24,42,1];原数组并未发生变化</span><br></pre></td></tr></table></figure>
<p>JQuery $.each</p>
<p>1.与ES5 forEach类似，但是第一二两个参数相反。<br>2.支持IE9之前版本。<br>3.能遍历数组和类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.each( [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], function(i, v)&#123; </span><br><span class="line">alert( i + &quot;: &quot; + v ); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">$.each( &#123; name: &quot;John&quot;, lang: &quot;JS&quot; &#125;, function(k, v)&#123; </span><br><span class="line">alert( &quot;Name: &quot; + k + &quot;, Value: &quot; + v ); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>JQuery $.map</p>
<p>1.与ES5 map类似，但是第一二两个参数相反。<br>2.支持IE9之前版本。<br>3.能遍历数组和类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr=$.map( [0,1,2], function(v)&#123; </span><br><span class="line">return v + 4; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">$.map(&#123;&quot;name&quot;:&quot;Jim&quot;,&quot;age&quot;:17&#125;,function(k, v)&#123; </span><br><span class="line">console.log( k+&quot;:&quot;+v ); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>再纠正个认知错误：each方法是JQuery对象的方法，对JQuery对象数组进行遍历，this指向该DOM对象，同理也有JQuery对象的map方法。</p>

            
        </article>
    </div>
    
</section>

    <nav class="nexmoe-page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/categories/技术/page/2/">2</a><a class="page-number" href="/categories/技术/page/3/">3</a><a class="extend next" rel="next" href="/categories/技术/page/2/"><i class="nexmoefont icon-right"></i></a>
    </nav>
  
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1565793202758"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>

  





</body>

</html>
