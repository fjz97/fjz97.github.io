<!DOCTYPE html>
<html>

<head>
  
  <title>标签：java - 冯京哲的狗窝</title>
  <meta charset="UTF-8">
  <meta name="description" content="feng&#39;s blog">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta name="description" content="feng&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="冯京哲的狗窝">
<meta property="og:url" content="http://www.fengjingzhe.com/tags/java/index.html">
<meta property="og:site_name" content="冯京哲的狗窝">
<meta property="og:description" content="feng&apos;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="冯京哲的狗窝">
<meta name="twitter:description" content="feng&apos;s blog">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="/css/style.css?v=1566144354750">
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/bg.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="feng" class="mdui-btn mdui-btn-icon"><img src="/images/avatar.jpg"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="feng">
            <img src="/images/avatar.jpg" alt="feng">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>33</div>
        <div><span>标签</span>11</div>
        <div><span>分类</span>3</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/7822981" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/fjz97/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/配置/">配置</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div class="nexmoe-widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/j2ee/" style="font-size: 14px;">j2ee</a> <a href="/tags/jQuery/" style="font-size: 16px;">jQuery</a> <a href="/tags/java/" style="font-size: 18px;">java</a> <a href="/tags/javascript/" style="font-size: 12px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/随笔/" style="font-size: 14px;">随笔</a>
    </div>
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul>
    </div>
  </div>


  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2019 feng
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts" id="brand-waterfall">
    
    <div class="nexmoe-post">
        <a href="/2018/05/16/java File返回什么路径/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="java File返回什么路径">
                
                <h1>java File返回什么路径</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年05月16日</a>
            <a><i class="nexmoefont icon-areachart"></i>796 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 3 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>Android7.0为了进一步加强私有文件的安全性，不再由开发者放宽私有文件的访问权限，这就意味着我们在代码中不能再随心所欲地操纵一些文件。</p>
<p>昨天在做更新app并打开安装包的时候，就报了FileUriExposedException 异常。经过百度，找到了解决的办法——使用FileProvider，<a href="https://www.jianshu.com/p/3f9e3fc38eae" target="_blank" rel="noopener">参考文章在这里</a>。照着文章使用了FileProvider后，却出现了解析程序包时出现问题。</p>
<p><img src="/images/26/problem.png" alt="解析程序包时出现问题"></p>
<p>查看log发现了如下的warning：</p>
<pre><code>Error staging apk from content URI: content://com.fengjingzhe.fightpicture.fileprovider/download/file%3A/storage/emulated/0/Android/data/com.fengjingzhe.fightpicture/files/Download/fightpicture-1.1.2.apk
                                                     java.io.FileNotFoundException: No such file or directory
</code></pre><p>也就是说，uri出了错误，系统找不到apk文件了。我赶紧查看生成uri的代码。</p>
<pre><code>Uri apkUri = FileProvider.getUriForFile(MainActivity.this, &quot;com.fengjingzhe.fightpicture.fileprovider&quot;, file);
</code></pre><p>这个uri是通过官方的api生成的，网上也都是使用了这个方法，理应不会有错猜对啊！！！真是百思不得其解！！！</p>
<p>反复观察了这个生成的uri，我猜测问题出在了中间的<code>file%3A</code>上。抱着试一试的心态，我自己拼接了一下uri：</p>
<p><code>content://com.fengjingzhe.fightpicture.fileprovider/download/storage/emulated/0/Android/data/com.fengjingzhe.fightpicture/files/Download/fightpicture-1.1.2.apk</code></p>
<p>运行程序，居然成功了！成功打开了这个apk，进入安装界面。</p>
<p>那么为什么官方的api生成的uri出错了呢？我深入FileProvider源码仔细查看，看了大半个晚上，仍然没有找出猫腻，只能悻悻然会宿舍了。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>时间回到今天，我在测试<code>File.getAbsolutePath()</code>和<code>File.getPath()</code>两个方法返回的路径究竟有什么区别的时候，为了省事，直接在项目中找现成的File类进行测试，其中就包括了这个下载好的apk。这时，意料之外的情况发生了。我发现，不同的两个文件，就算是同一个<code>getPath()</code>方法，居然返回的路径格式大相径庭。比如，这个apk文件返回了这样一个路径：</p>
<p><code>file:/storage/emulated/0/Android/data/com.fengjingzhe.fightpicture/files/Download/fightpicture-1.1.2.apk</code></p>
<p>而一张图片文件返回了这样一个路径：</p>
<p><code>/storage/emulated/0/fightpicture/1526470886506.jpg</code></p>
<p>抱着疑问，我打开了File的源码，这里贴出关键部分：</p>
<pre><code>    public File(String pathname) {
        if (pathname == null) {
            throw new NullPointerException();
        }
        //nomalize方法去除了头尾多余的斜杠
        this.path = fs.normalize(pathname);
        this.prefixLength = fs.prefixLength(this.path);
    }

    public String getPath() {
        return path;
    }
</code></pre><p>也就是说，你的构造方法传什么样的路径，getPath()方法就会返回给你什么样的路径，而构造方法恰恰接受file:///和/开头的两种类型路径。</p>
<p>回到getUriForFile方法上来，之所以返回的uri多了一点东西，就是因为我们的apk文件的getPath方法返回的路径多了file:///的前缀。那么，我们在getUriForFile方法中给它传一个/前缀的文件，返回的uri是不是就正常了呢？我们改动代码：</p>
<pre><code>File file = new File(Uri.parse(filename).getEncodedPath());
                    Uri apkUri = FileProvider.getUriForFile(MainActivity.this, &quot;com.fengjingzhe.fightpicture.fileprovider&quot;, file);
</code></pre><p>果然，成功打开了apk文件，进入了安装界面。问题成功解决了。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/04/28/java多线程下载/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="java多线程下载">
                
                <h1>java多线程下载</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年04月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <p>在上一篇文章里，我们讨论了图片缓存速度慢的原因，发现IO并不是决定因素。那么问题出在哪呢？一篇关于java多线程下载的博客引起了我的注意：我们知道迅雷、旋风等下载器都是多线程下载的，会不会是单线程效率的问题影响了图片缓存速度呢？事不宜迟，我们开始验证。</p>
<hr>
<h1 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h1><p>多线程下载的原理很简单，无非就是分段请求数据，最后再把每段数据拼凑起来，实现起来需要解决两个问题， 没错，就是怎么分段请求和怎么拼接数据。</p>
<h2 id="1-HTTP-1-1-Header-Range"><a href="#1-HTTP-1-1-Header-Range" class="headerlink" title="1.HTTP/1.1 Header Range"></a>1.HTTP/1.1 Header Range</h2><p>首先面临的问题是，怎么分段请求数据。<br>HTTP/1.1引入了一个新的header，名字叫做Range，它可以指定一个范围，然后http请求就会只请求那一段的数据，java代码可以这样写：</p>
<p><code>conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + start + &quot;-&quot; + end);</code></p>
<p>其中start就是数据的开始字节，end是数据的结束字节。</p>
<h2 id="2-RandomAccessFile"><a href="#2-RandomAccessFile" class="headerlink" title="2.RandomAccessFile"></a>2.RandomAccessFile</h2><p>第二个问题是，怎么将这些分段的数据拼接起来。<br>这里我们需要用到java随机访问文件RandomAccessFile，它指定文件并通过seek方法跳转到该文件的任意字节处进行读写操作。于是我们的java代码可以这么写：</p>
<pre><code>                raf = new RandomAccessFile(file, &quot;rw&quot;);
                raf.seek(start);
                byte[] bytes = new byte[1024];
                int len;
                while ((len = is.read(bytes)) != -1) {
                    raf.write(bytes, 0, len);
                }
</code></pre><p>为了方便测试，我写了一个java demo，代码如下：</p>
<pre><code>public class Main {

    private static final String PICTURE_URL = &quot;http://d1.music.126.net/dmusic/CloudMusic_official_5.1.0.573520.apk&quot;;
    private static final String FILE_NAME = &quot;cloudmusic.apk&quot;;
    private static final int THREAD_NUM = 10;
    private static long startTime;
    private static long endTime;
    private static double usetime;
    private static int count = 0;

    public static void main(String[] args) {
        startTime = System.currentTimeMillis();
        try {
            File file = new File(&quot;C:/cdt/&quot;, FILE_NAME);
            URL url = new URL(PICTURE_URL);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            int size = conn.getContentLength();
            int piece = size % THREAD_NUM == 0 ? size / THREAD_NUM : (size / THREAD_NUM + 1);
            for (int j = 0; j &lt; THREAD_NUM; j++) {
                int start = j * piece;
                int end = (j + 1) * piece - 1;
                if (j == THREAD_NUM - 1) end = size;
                new DownloadThread(file, url, start, end).start();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static class DownloadThread extends Thread {
        private File file;
        private URL url;
        private int start;
        private int end;

        public DownloadThread(File file, URL url, int start, int end) {
            this.file = file;
            this.url = url;
            this.start = start;
            this.end = end;
        }

        public void run() {
            InputStream is = null;
            RandomAccessFile raf = null;
            try {
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + start + &quot;-&quot; + end);
                is = conn.getInputStream();
                raf = new RandomAccessFile(file, &quot;rw&quot;);
                raf.seek(start);
                byte[] bytes = new byte[1024];
                int len;
                while ((len = is.read(bytes)) != -1) {
                    raf.write(bytes, 0, len);
                }
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    raf.close();
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                checkFinish(++count);
            }
        }

        public void checkFinish(int count) {
            if (count == THREAD_NUM) {
                endTime = System.currentTimeMillis();
                usetime = (endTime - startTime) / 1000.0;
                System.out.println(&quot;下载用时为：&quot; + usetime + &quot;s&quot;);
            }
        }
    }
}
</code></pre><p>事不宜迟，我们赶紧把demo跑起来，先尝试一下用单线程下载网易云音乐apk文件的用时。</p>
<p><img src="/images/7/usetime1.png" alt="usetime"></p>
<p>接着用3个线程来下载看看。</p>
<p><img src="/images/7/usetime2.png" alt="usetime"></p>
<p>速度果然有所提升，快了大约4秒。</p>
<p>那么换成10个进程进行下载呢？</p>
<p><img src="/images/7/usetime3.png" alt="usetime"></p>
<p>速度仍有提升，但是提升已经不大了。</p>
<hr>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>接下来我们就用多线程下载来下载一下服务器上的图片文件，看看速度是否有所提升，我们把url换成图片url。</p>
<pre><code>private static final String PICTURE_URL = &quot;http://101.132.185.255:8080/resource/fightpicture/gallery/QQ%E5%9B%BE%E7%89%8720180330214156.gif&quot;;
</code></pre><p>demo运行结果：</p>
<p><img src="/images/7/usetime4.png" alt="usetime"></p>
<p>结果显示，1.8M的gif图片，仍然下载了约13秒，与之前单线程下载如出一辙。</p>
<hr>
<h1 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h1><p>前面通过下载网易云音乐apk文件的例子，我们知道了40M左右的文件10秒内就下载完毕了，这么来说，java性能的原因就可以直接被排除了，那么很显然，多半是服务器的速度问题。首先服务器的带宽应该不成问题，我在服务器上下载文件速度可以达到10M/S，那么多半就是tomcat的性能问题了，或许是tomcat用作静态文件服务器表现并不好。我尝试把apk文件放在了tomcat下,通过浏览器url直接去下载。</p>
<p><img src="/images/7/download.png" alt="download"></p>
<p>果然，速度维持在140KB/S左右，与我们下载gif图片的速度如出一辙。</p>
<hr>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>tomcat作为文件服务器的表现性能不佳，这点我本该早点预料到。通过百度，我了解到一般通过云存储+CDN加速的方案托管我们的静态资源，例如阿里云的OSS，才能让文件下载速度真正提升上去。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/04/04/java BufferedOutputStream的骗局/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="java BufferedOutputStream的骗局">
                
                <h1>java BufferedOutputStream的骗局</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年04月04日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 6 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <p>文章的开始，先从一个案例谈起。<br>最近在做的项目中有图片保存的需求，之前一律按jpg格式处理了，今天想想不妥，于是适配了所有的图片格式。代码如下：</p>
<pre><code>        try {
            FileOutputStream fos = new FileOutputStream(file);
            int length;
            byte[] bytes = new byte[10240];
            while((length = is.read(bytes, 0, 10240)) != -1) {
                fos.write(bytes, 0, length);
            }
            fos.close();
            is.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
</code></pre><p>项目跑起来，试着保存了一张gif图片，显示成功，本以为大功告成，结果切到本地图片gallery一看，图片根本没有保存成功。正愣着呢，图片又突然出现了。我稍微一想，就知道是保存图片的速度过慢。输出看了下缓存图片的耗时。</p>
<p><img src="/images/6/usetime.png" alt="usetime"></p>
<p>2MB的gif图片足足缓存了十几秒，用户体验想必是很差的，那么有没有办法加快缓存速度呢？我的java知识告诉我，有！使用BufferedOutputStream维护一个字节缓冲池以减少IO次数，提升缓存速度。于是我使用了BufferedOutputStream：</p>
<pre><code>            FileOutputStream fos = new FileOutputStream(file);
            BufferedOutputStream bos = new BufferedOutputStream(fos);
            int length;
            byte[] bytes = new byte[10240];
            while((length = is.read(bytes, 0, 10240)) != -1) {
                bos.write(bytes, 0, length);
            }
            bos.flush();
            bos.close();
            is.close();
</code></pre><p>这回跑起来肯定快了吧！结果：</p>
<p><img src="/images/6/usetime2.png" alt="usetime2"></p>
<p>根本没有变快嘛！怎么回事？难道我记错了？抱着疑惑，我打开了BufferedOutputStream源码：</p>
<pre><code>public
class BufferedOutputStream extends FilterOutputStream {
    /**
     * The internal buffer where data is stored.
     */
    protected byte buf[];

    /**
     * The number of valid bytes in the buffer. This value is always
     * in the range &lt;tt&gt;0&lt;/tt&gt; through &lt;tt&gt;buf.length&lt;/tt&gt;; elements
     * &lt;tt&gt;buf[0]&lt;/tt&gt; through &lt;tt&gt;buf[count-1]&lt;/tt&gt; contain valid
     * byte data.
     */
    protected int count;

    /**
     * Creates a new buffered output stream to write data to the
     * specified underlying output stream.
     *
     * @param   out   the underlying output stream.
     */
    public BufferedOutputStream(OutputStream out) {
        this(out, 8192);
    }

    /**
     * Creates a new buffered output stream to write data to the
     * specified underlying output stream with the specified buffer
     * size.
     *
     * @param   out    the underlying output stream.
     * @param   size   the buffer size.
     * @exception IllegalArgumentException if size &amp;lt;= 0.
     */
    public BufferedOutputStream(OutputStream out, int size) {
        super(out);
        if (size &lt;= 0) {
            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
        }
        buf = new byte[size];
    }

    /** Flush the internal buffer */
    private void flushBuffer() throws IOException {
        if (count &gt; 0) {
            out.write(buf, 0, count);
            count = 0;
        }
    }

    /**
     * Writes the specified byte to this buffered output stream.
     *
     * @param      b   the byte to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public synchronized void write(int b) throws IOException {
        if (count &gt;= buf.length) {
            flushBuffer();
        }
        buf[count++] = (byte)b;
    }

    /**
     * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array
     * starting at offset &lt;code&gt;off&lt;/code&gt; to this buffered output stream.
     *
     * &lt;p&gt; Ordinarily this method stores bytes from the given array into this
     * stream&#39;s buffer, flushing the buffer to the underlying output stream as
     * needed.  If the requested length is at least as large as this stream&#39;s
     * buffer, however, then this method will flush the buffer and write the
     * bytes directly to the underlying output stream.  Thus redundant
     * &lt;code&gt;BufferedOutputStream&lt;/code&gt;s will not copy data unnecessarily.
     *
     * @param      b     the data.
     * @param      off   the start offset in the data.
     * @param      len   the number of bytes to write.
     * @exception  IOException  if an I/O error occurs.
     */
    public synchronized void write(byte b[], int off, int len) throws IOException {
        if (len &gt;= buf.length) {
            /* If the request length exceeds the size of the output buffer,
               flush the output buffer and then write the data directly.
               In this way buffered streams will cascade harmlessly. */
            flushBuffer();
            out.write(b, off, len);
            return;
        }
        if (len &gt; buf.length - count) {
            flushBuffer();
        }
        System.arraycopy(b, off, buf, count, len);
        count += len;
    }

    /**
     * Flushes this buffered output stream. This forces any buffered
     * output bytes to be written out to the underlying output stream.
     *
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterOutputStream#out
     */
    public synchronized void flush() throws IOException {
        flushBuffer();
        out.flush();
    }
}
</code></pre><p>我没记错，BufferedOutputStream确实维护了一个byte数组，先往byte数组里面填充字节，当byte数组满了，再写出去。但是，如果不设置参数，缓冲池的大小只有8192byte，也就是说，我10240byte一次的写出大小反而增多了IO次数，也难怪速度没有提升。我试着加大了BufferedOutputStream的buffer大小：</p>
<p><code>BufferedOutputStream bos = new BufferedOutputStream(fos, 1000 * 1024);</code></p>
<p>结果：</p>
<p><img src="/images/6/usetime3.png" alt="usetime3"></p>
<p>速度还是没有提升，那么只有一种可能了，IO根本不是影响缓存速度的决定因素。或者说，这么点次数的IO不会是影响缓存速度的决定因素。为了证实我的猜想，我们试试看每次只读入写出1个字节，增多读入写出次数，增大IO开销：</p>
<pre><code>            FileOutputStream fos = new FileOutputStream(file);
            int data;
            while((data = is.read()) != -1) {
                fos.write(data);
            }
            fos.close();
            is.close();
</code></pre><p>结果：</p>
<p><img src="/images/6/usetime4.png" alt="usetime4"></p>
<p>终于，在这种极端情况下，缓存图片的时间终于增长了！本来是费尽心机想减少缓存时间，现在竟然费尽心机想增长缓存时间！</p>
<p>既然IO不是影响缓存速度的决定因素，那么，使用BufferedOutputStream的意义似乎就不存在了。</p>
<p><strong>另外，如果想要减少IO次数，直接增大代码中的byte数组不就可以了吗，别忘了，我们使用read(bytes[], int, int)和write(bytes[], int, int)这种有别于无参数的read和一个参数的write方法，其实就是做了和BufferedOutputStream一样的工作——维护一个缓冲池。这么一看，BufferedOutputStream的存在意义，似乎也不存在了。</strong></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2017/03/24/Java Timer学习笔记/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="Java Timer学习笔记">
                
                <h1>Java Timer学习笔记</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年03月24日</a>
            <a><i class="nexmoefont icon-areachart"></i>349 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <p>Timer是java1.3引入util包的一个类，作用是定时完成任务，每次开启一个线程进行任务，所以可以执行耗时操作，当然，如果要进行ui修改，请用Handler在ui线程中进行。</p>
<p>打开Timer类的源文件</p>
<p><img src="/images/18/Timer.png" alt="Timer"></p>
<p>先不管TimerThread和TaskQueue两个辅助类，只看Timer类，简洁明了，除了构造方法外只剩下schedule和scheduleAtFixedRate两个方法，这也是Timer类的两个核心方法。</p>
<p>在讲这两个方法之前先解释一下TimerTask类，这是一个实现了Runnable的抽象类，这个抽象类加入了对run方法执行状态的判断。</p>
<p>1.schedule(TimerTask, long):在指定时间后执行TimerTask。</p>
<p>2.schedule(TimerTask, long, long):在指定时间后执行TimerTask，并以后一个指定时间为周期重复执行。</p>
<p>scheduleAtFixedRate与schedule不同之处在于前者是以开始时间为基准计算下一次执行时间，而后者以前一次执行的时间为基准计算下一次执行时间。什么意思呢，加入我们设定周期为5秒，开始时间为0秒后，而第一次执行却在第8秒，那么scheduleAtFixedRate方法会尽量在第10秒执行下一次，而schedule方法则会尽量在第13秒执行下一次。</p>
<p>所以说在需要保证20秒执行4次的情况下，使用scheduleAtFixedRate方法更有保障。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2017/02/22/《Java SE 8 for the really impatient》第三章习题笔记/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="《Java SE 8 for the really impatient》第三章习题笔记">
                
                <h1>《Java SE 8 for the really impatient》第三章习题笔记</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年02月22日</a>
            <a><i class="nexmoefont icon-areachart"></i>142 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <p>2.</p>
<pre><code>    public static void main(String[] args) {
        ReentrantLock myLock = new ReentrantLock();
        withLock(myLock, ()-&gt;{
            System.out.println(&quot;running&quot;);
        });
    }

    public static void withLock(ReentrantLock myLock, Runnable runnable) {
        myLock.lock();
        try {
            runnable.run();
        } finally {
            myLock.unlock();
        }
    }
</code></pre><hr>
<p>5.</p>
<pre><code>    public static void main(String[] args) {
        Image image = new Image(&quot;C:/Users/Administrator/Desktop/1.jpg&quot;);
        Image newImage = transform(image, (x, y, colorAtXY) -&gt; {
            if(x&lt;10||x&gt;image.getWidth()-10||y&lt;10||y&gt;image.getHeight()-10) {
                return Color.GREY;
            } else {
                return colorAtXY;
            }
        });
    }

    public static Image transform(Image in, ColorTransformer cf) {
        int width = (int) in.getWidth();
        int height = (int) in.getHeight();
        WritableImage out = new WritableImage(width, height);
        for(int x = 0; x &lt; width; x++) {
            for(int y = 0; y &lt; height; y++) {
                out.getPixelWriter().setColor(x, y, cf.apply(x, y, in.getPixelReader().getColor(x, y)));
            }
        }
        return out;
    }
</code></pre>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2017/02/15/《Java SE 8 for the really impatient》第二章习题笔记/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="《Java SE 8 for the really impatient》第二章习题笔记">
                
                <h1>《Java SE 8 for the really impatient》第二章习题笔记</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年02月15日</a>
            <a><i class="nexmoefont icon-areachart"></i>451 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <p>3.</p>
<pre><code>            long startTime = System.nanoTime();
            long countNotParallel = words.stream().count();
            long endTime = System.nanoTime();
            long time = endTime-startTime;
            System.out.println(&quot;stream方法：&quot; + time + &quot; 统计单词数为：&quot; + countNotParallel);

            startTime = System.nanoTime();
            long countParallel = words.parallelStream().count();
            endTime = System.nanoTime();
            time = endTime - startTime;
            System.out.println(&quot;streamParallel方法：&quot; + time + &quot; 统计单词数为：&quot; + countParallel);

            startTime = System.nanoTime();
            words.parallelStream();
            endTime = System.nanoTime();
            time = endTime - startTime;
            System.out.println(&quot;stream生成耗时：&quot; + time);
</code></pre><p>顺便做了个stream生成耗时测试，运行结果可以看出stream是延时操作，只有当聚合方法被调用才会被执行。</p>
<hr>
<p>6.</p>
<pre><code>    public static void main(String[] args) {
        String string = &quot;feng jing zhe da shuai b&quot;;
        characterStream(string).filter(c -&gt; c != &#39; &#39;).forEach(System.out::print);
    }

    public static Stream&lt;Character&gt; characterStream(String s) {
        return Stream.iterate(0, n-&gt;n+=1).limit(s.length()).map(s::charAt);
    }
</code></pre><p>注意这里是对象的方法引用。</p>
<hr>
<p>9.</p>
<pre><code>    public static void main(String[] args) {
        String string = &quot;feng jing zhe&quot;;
        ArrayList&lt;String&gt; stringList = new ArrayList&lt;String&gt;(Arrays.asList(string.split(&quot; &quot;)));
        Stream&lt;ArrayList&lt;String&gt;&gt; stream = Stream.of(stringList, stringList, stringList, stringList);
        ArrayList&lt;String&gt; concatList = concat(stream);
        concatList.forEach(System.out::print);
    }

    public static &lt;T&gt; ArrayList&lt;T&gt; concat(Stream&lt;ArrayList&lt;T&gt;&gt; stream) {
        Optional&lt;ArrayList&lt;T&gt;&gt; optional = stream.reduce(Test::arrayListConcat);
        return optional.get();
    }

    public static &lt;T&gt; ArrayList&lt;T&gt; arrayListConcat(ArrayList&lt;T&gt; prev, ArrayList&lt;T&gt; next) {
        ArrayList&lt;T&gt; temp = (ArrayList&lt;T&gt;) prev.clone();
        temp.addAll(next);
        return temp;
    }
</code></pre><p>注意reduce（聚合）和collect（收集）的区别，就是让Stream&lt;ArrayList<t>&gt;转换成ArrayList<t>和ArrayList&lt;ArrayList<t>&gt;的区别。</t></t></t></p>
<hr>
<p>12.</p>
<pre><code>            String content = new String(Files.readAllBytes(Paths.get(
                    &quot;C:/Users/Administrator/Desktop/WarAndPeace.txt&quot;)), &quot;UTF-8&quot;);
            List&lt;String&gt; words = Arrays.asList(content.split(&quot;[\\P{L}]+&quot;));
            Stream&lt;String&gt; stream = words.stream();
            AtomicInteger[] wordLengthNum = new AtomicInteger[5];
            for (int i = 0; i &lt; wordLengthNum.length; i++) {
                AtomicInteger atomicInteger = new AtomicInteger(0);
                wordLengthNum[i] = atomicInteger;
            }
            stream.parallel().forEach(s-&gt;{
                if (s.length() &lt;= 5) {
                    wordLengthNum[s.length()-1].incrementAndGet();
                }
            });
            for (AtomicInteger atomicInteger : wordLengthNum) {
                System.out.println(atomicInteger);
            }
</code></pre><hr>
<p>13.</p>
<pre><code>Map&lt;Integer, Long&gt; result = stream.collect(Collectors.groupingBy(String::length, Collectors.counting()));
</code></pre>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2017/02/09/《Java SE 8 for the really impatient》第一章习题笔记/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/bg.jpg" alt="《Java SE 8 for the really impatient》第一章习题笔记">
                
                <h1>《Java SE 8 for the really impatient》第一章习题笔记</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2017年02月09日</a>
            <a><i class="nexmoefont icon-areachart"></i>390 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/java/">java</a>
            
        </div>
        <article>
            
            <p>2.</p>
<p>lambda表达式：</p>
<pre><code>    public static File[] getChildDirectory(File file) {
        return file.listFiles(pathname -&gt; {
            if(pathname.isDirectory()) {
                return true;
            }
            else {
                return false;
            }
        });
</code></pre><p>方法引用：</p>
<pre><code>    public static File[] getChildDirectory(File file) {
        return file.listFiles(File::isDirectory);
    }
</code></pre><hr>
<p>3.</p>
<pre><code>    public static File[] getChildFilesByExt(File file, String ext) {
        return file.listFiles((dir, name) -&gt; {
            if (name.substring(name.lastIndexOf(&quot;.&quot;) + 1).equals(ext)) {
                return true;
            } else {
                return false;
            }
        });
    }
</code></pre><p>捕获file以及ext。</p>
<hr>
<p>6.</p>
<pre><code>public class Test {
    public static void main(String[] args) {

        new Thread(uncheck(() -&gt; {
            System.out.println(&quot;start&quot;);
            Thread.sleep(1000);
            System.out.println(&quot;end&quot;);
        })).start();
    }

    public static Runnable uncheck(RunnableEx runnableEx) {
        return new Runnable() {
            @Override
            public void run() {
                try {
                    runnableEx.run();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        };
    }
}

interface RunnableEx {
    public void run() throws Exception;
}
</code></pre><p> uncheck实际上做的事就是，封装了一个Runnable并返回，其中Runnable的run方法调用了lambda表达式的代码段并检查了代码段。</p>
<p>我感觉是可以用<code>Callable&lt;Void&gt;</code>的，在代码段最后加上<code>return null</code>就可以了，确实可以跑起来。</p>
<hr>
<p>7.</p>
<pre><code>    public static void main(String[] args) {

        andThen(()-&gt;{System.out.println(&quot;1&quot;);}, ()-&gt;{System.out.println(&quot;2&quot;);});

    }

    public static Thread[] andThen(Runnable a, Runnable b) {
        Thread thread1 = new Thread(a);
        thread1.start();
        Thread thread2 = new Thread(b);
        thread2.start();
        Thread[] threads = new Thread[2];
        return threads;
    }
</code></pre><hr>
<p>8.</p>
<pre><code>    String[] names = { &quot;Peter&quot;, &quot;Paul&quot;, &quot;Merry&quot; };
    List&lt;Runnable&gt; runners = new ArrayList&lt;Runnable&gt;();
    for(String name : names) {
        runners.add(() -&gt; System.out.println(name));
    }
    for(Runnable r : runners) {
        new Thread(r).start();
    }
</code></pre><p>合法</p>
<p>如果使用传统的for循环，不合法，编译器报错Local variable i defined in an enclosing scope must be final or effectively final。捕获的i值发生了变化，即为非法。与内部类相同，JDK1.8开始可以在内部类和lambda表达式中使用非final局部变量，前提是值不发生改变（本质上还是final的）。</p>

            
        </article>
    </div>
    
</section>

    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1566144354756"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>

  





</body>

</html>
